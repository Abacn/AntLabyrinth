//
//  baseleech.cpp
//  InvadePercolation
//
//  Created by Yi Hu on 6/26/22.
//

// Generate base vectors of Leech lattice

#include "leathsitenode.hpp"

#if 24==DIM

constexpr int NUM_VECS = 98280;
constexpr int NUM_CODES = 4096;
constexpr int NUM_OCTADS = 759;

#ifdef _MSC_VER
#  include <intrin.h>
#  define __builtin_popcount(A) _mm_popcnt_u32(A)
#endif

#ifndef __POPCNT__
#pragma warning( POPCNT instruction not enabled)
#endif


// generates Golay codes and its octads used to construct the Leech lattice.
void getGolayCodes(uint32_t* codes, uint32_t* octads)
{
  // from https://en.wikipedia.org/wiki/Binary_Golay_code
  const uint32_t generator_materix[12]= {
    0b100000000000100111110001,        // row  1
    0b010000000000010011111010,        // row  2
    0b001000000000001001111101,        // row  3
    0b000100000000100100111110,        // row  4
    0b000010000000110010011101,        // row  5
    0b000001000000111001001110,        // row  6
    0b000000100000111100100101,        // row  7
    0b000000010000111110010010,        // row  8
    0b000000001000011111001001,        // row  9
    0b000000000100001111100110,        // row 10
    0b000000000010010101010111,        // row 11
    0b000000000001101010101011         // row 12
  };
  int idx = 0;
  // iterate over all 4096 golay codes using generator
  for(int rp=0; rp<NUM_CODES; ++rp)
  {
    uint32_t codeword = 0, v = rp;
    for(int rq=0; rq<12; ++rq)
    {
      if(v & 1)
      {
        codeword ^= generator_materix[rq];
      }
      v >>= 1;
    }
    if(__builtin_popcount(codeword) == 8)
    {
      octads[idx++] = codeword;
    }
    codes[rp] = codeword;
  }
}

// get all indices of 1 in a Golay octad
void getGolayOctadIndex(uint32_t codeword, unsigned char* idxs)
{
  unsigned char rq = 0;
  for(unsigned char rp=0; rp<24; ++rp)
  {
    if((codeword >> rp) & 1)
    {
      idxs[rq++] = rp;
    }
  }
}

// Return half of the 196,560 base vectors for the Leech lattice.
// Another half can be generated by simply taking the negative of them.
const LeathSiteNode* baseleech(void)
{
  LeathSiteNode* leechbase = new LeathSiteNode[NUM_VECS];
  int idx = 0;
  // 552 pm(4^2, 0^22) - any sign
  for(int i=0; i<DIM-1; ++i)
  {
    for(int j=i+1; j<DIM; ++j)
    {
      leechbase[idx][i] = 4;
      leechbase[idx][j] = 4;
      ++idx;
      leechbase[idx][i] = 4;
      leechbase[idx][j] = -4;
      ++idx;
    }
  }
  uint32_t* codes = new uint32_t[NUM_CODES];
  uint32_t* octads = new uint32_t[NUM_OCTADS];
  // 48576 (2^8, 0^16) - 2s are in golay code octads and there are even number of minus
  getGolayCodes(codes, octads);
  for(int rp=0; rp<NUM_OCTADS; ++rp)
  {
    unsigned char idxof1s[8];
    getGolayOctadIndex(octads[rp], idxof1s);
    // 0 minus sign
    for(int i=0; i<8; ++i)
    {
      leechbase[idx][idxof1s[i]] = 2;
    }
    ++idx;
    // 2 minus signs
    for(int i=0; i<7; ++i)
    {
      for(int j=i+1; j<8; ++j)
      {
        for(int k=0; k<8; ++k)
        {
          leechbase[idx][idxof1s[k]] = 2;
        }
        leechbase[idx][idxof1s[i]] = -2;
        leechbase[idx][idxof1s[j]] = -2;
        ++idx;
      }
    }
    // 4 minus signs
    for(int i=0; i<5; ++i)
    {
      for(int j=i+1; j<6; ++j)
      {
        for(int k=j+1; k<7; ++k)
        {
          for(int l=0; l<7; ++l)
          {
            leechbase[idx][idxof1s[l]] = 2;
          }
          leechbase[idx][idxof1s[i]] = -2;
          leechbase[idx][idxof1s[j]] = -2;
          leechbase[idx][idxof1s[k]] = -2;
          leechbase[idx][idxof1s[7]] = -2; // fix last minus sign to idxof1s[7]
          ++idx;
        }
      }
    }
  }
  // 49152 (mp 3, pm 1^23)
  for(int rp=0; rp<NUM_CODES; ++rp)
  {
    uint32_t codeword = codes[rp];
    for(int rq=0; rq<DIM; ++rq)
    {
      // only assign 3 to the golay code's 0
      if(!((codeword >> rq) & 1))
      {
        for(int i=0; i<DIM; ++i)
        {
          leechbase[idx][i] = 1 - 2*((codeword >> i) & 1);
        }
        leechbase[idx][rq] = 3;
        ++idx;
      }
    }
  }
  delete [] codes;
  delete [] octads;
  return leechbase;
}
#endif
